<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with jLaTeX2HTML 2002-2-1 (1.70) JA patch-2.0
patched version by:  Kenshi Muto, Debian Project.
* modified by:  Shige TAKENO
LaTeX2HTML 2002-2-1 (1.70),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>NAT transversal: some approaches</TITLE>
<META NAME="description" CONTENT="NAT transversal: some approaches">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="jLaTeX2HTML v2002-2-1 JA patch-2.0">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ntcp.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="ntcp.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html154"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html150"
  HREF="ntcp.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html144"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A> 
<A NAME="tex2html152"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="file:/usr/share/latex2html/icons/contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html155"
  HREF="node7.html">Our Approach</A>
<B> Up:</B> <A NAME="tex2html151"
  HREF="ntcp.html">Peer-to-Peer Reliable Connectivity Across</A>
<B> Previous:</B> <A NAME="tex2html145"
  HREF="node5.html">Solution requirements</A>
 &nbsp; <B>  <A NAME="tex2html153"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html156"
  HREF="node6.html#SECTION00610000000000000000">STUN: Simple Traversal of UDP protocol Through NATs</A>
<UL>
<LI><A NAME="tex2html157"
  HREF="node6.html#SECTION00611000000000000000">Terminology</A>
<LI><A NAME="tex2html158"
  HREF="node6.html#SECTION00612000000000000000">Overview of operations</A>
</UL>
<BR>
<LI><A NAME="tex2html159"
  HREF="node6.html#SECTION00620000000000000000">STUNT: Simple Traversal of UDP Through NATs and TCP too</A>
<LI><A NAME="tex2html160"
  HREF="node6.html#SECTION00630000000000000000">Hole Punching</A>
<UL>
<LI><A NAME="tex2html161"
  HREF="node6.html#SECTION00631000000000000000">UDP Hole Punching</A>
<UL>
<LI><A NAME="tex2html162"
  HREF="node6.html#SECTION00631010000000000000">Peers behind different NATs</A>
<LI><A NAME="tex2html163"
  HREF="node6.html#SECTION00631020000000000000">Peers behind multiple levels of NAT</A>
<LI><A NAME="tex2html164"
  HREF="node6.html#SECTION00631030000000000000">Peers behind the same NAT: the hairpin translation</A>
<LI><A NAME="tex2html165"
  HREF="node6.html#SECTION00631040000000000000">Create a peer-to-peer UDP session</A>
</UL>
<LI><A NAME="tex2html166"
  HREF="node6.html#SECTION00632000000000000000">TCP Hole Punching</A>
<UL>
<LI><A NAME="tex2html167"
  HREF="node6.html#SECTION00632010000000000000">Create a peer-to-peer TCP session</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00600000000000000000">
NAT transversal: some approaches</A>
</H1>

<P>

<UL>
<LI>STUN (Simple Traversal of UDP protocol Through NATs): 
a UDP-based protocol to determine if the machine is NATed and
if so, via what type of NAT. It isn't a cure-all, it allows incoming
UDP packets through a subset of existing NAT types (it doesn't enable
incoming UDP packets through symmetric NATs) [<A
 HREF="node8.html#rfc_3489">12</A>]

<P>
</LI>
<LI>STUNT (Simple Traversal of UDP Through NATs and TCP too):
extends STUN to include TCP functionality. It is a lightweight protocol
that allows applications running behind a NAT to determine external
IP and port-binding properties, packet filtering rules and various
timeouts associated with TCP connections through the NAT.  Knowing
these parameters allows applications to establish TCP sessions
between two NAT'ed hosts.

<P>
</LI>
<LI>UPnP: The UPnP architecture offers pervasive peer-to-peer network
connectivity. The UPnP architecture is a distributed, open networking
architecture that leverages TCP/IP and the Web to enable seamless
proximity networking in addition to control and data transfer among
networked devices. Unfortunately, there are high security problems
and many NAT boxes turned off it. ... 

<P>
</LI>
<LI>IPv6: the new standard that specifies 128 bit IP addresses. It is
possible that the new longer IPv6 addresses will reduce the need for
a NAT box. However, as the adoption of the IPv6 addresses is slow,
the NAT boxes are used to bridge between IPv4 and IPv6 networks. 

<P>
</LI>
<LI>NUTSS: a SIP-based approach to UDP and TCP network connectivity that
proposes to combine NAT traversal, URIs, Tunneling over UDP, SIP and
STUN. It is a research project at Cornell [<A
 HREF="node8.html#nutss">5</A>]

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00610000000000000000">
STUN: Simple Traversal of UDP protocol Through NATs</A>
</H1>

<P>
STUN is a protocol that allows users to discover if there is 
a NAT between them and the public Internet and, in this case, 
the type of the NAT. It allows to discover if there is an UDP firewall too.  
With STUN, a peer-to-peer application can determine the public network address
allocated to it by the NAT, without require any special NAT behavior. 
The STUN's objective is to provide a mechanism for NATs traversal and allows 
applications to work through the existing NAT infrastructure.
This section resumes the STUN protocol defined in RFC 3489 [<A
 HREF="node8.html#rfc_3489">12</A>]

<P>

<H2><A NAME="SECTION00611000000000000000">
Terminology</A>
</H2>

<P>
In the STUN protocol there are two principal entities: a STUN client, that generates 
the STUN requests, and the STUN server that receives the STUN requests, 
and send STUN responses.

<P>

<H2><A NAME="SECTION00612000000000000000">
Overview of operations</A>
</H2>

<P>
To know behind what type of NAT the client is and to discover his public network
address, it starts the STUN discovery procedure sending the initial 
<I>Binding Request</I> to server using UDP [mattere nota per TCP]. 
A <I>Binding Request</I> that arrives to the server may have traversed one or multiple NAT 
levels, and it source address will be the mapped address created by the NAT closest
to the server. The server puts this address in a <I>Binding Response</I>
message and sends it back to the source IP address and port of the request.
The client compare the local IP and port with these send by the server. If the addresses 
are the same, between the client and the open Internet there are not NATs boxes. 
In the case of a mismatching one or more NATS are present.

<P>
If the NAT is a full-cone, the public IP and port mapped by the NAT are 
public and any host can use them to communicate with the user behind the NAT.
But the user is not sure that the NAT is a full-cone and if everybody can 
join it on this address. For this reason, it's necessary to follow 
in the STUN discovery procedure.

<P>
The client sends a second <I>Binding Request</I> from the same IP and port address 
but to a different IP address, to a second STUN server that reply with the 
public IP and port address that NAT mapped for this communication. 
If they are different from those in the first <I>Binding Response</I>, the client knows 
it is behind a symmetric NAT.
Otherwise, the client just  knows that the NAT is not a symmetric type and it must to
continues the discover procedure. 
It sends a <I>Binding Request</I> with flags that tell to the server to send a response
from a different IP address and port than the request was received on. 
If the client receives this response, it knows it is behind a full cone NAT. 
Otherwise the NAT can be a port restricted cone NAT or just a restricted cone NAT. 
To discover it, the client ask to STUN server, to sending a <I>Binding Response</I>
from the same IP address than the request was received on, but from onother port.
If a responce is received, the client is behind a just restricted NAT.

<P>

<H1><A NAME="SECTION00620000000000000000">
STUNT: Simple Traversal of UDP Through NATs and TCP too</A>
</H1>
Simple Traversal of UDP Through NATs (STUN) has enabled a new
generation of peer-to-peer applications that can function in the
presence of Network Address and Port Translators (NATs) devices.  It
allows applications to discover the presence and type of NAT and
learn the binding allocated by the NAT without requiring any changes
to the NATs themselves.  However, STUN is limited to UDP and does not
work for TCP.  The behavior of NATs when it comes to TCP is more
complex and cannot be captured with the mechanisms provided by STUN.

<P>
Lacking TCP support, many peer-to-peer applications fall back onto
transferring data over UDP.  As a result applications forfeit
congestion avoidance in the form of Explicit Congestion Notification
and instead each application must re-engineer TCP friendliness into
its UDP based protocol.  TCP friendliness often deviates from the
application's primary goals and is subsequently ignored causing
congestion problems later.  Another approach is to run an entire
TCP/IP stack encapsulated inside UDP datagrams.  This approach incurs
overheads introduced by encapsulation, decapsulation and transmission
of extra header data.

<P>
The protocol described here, Simple Traversal of UDP Through NAT and
TCP too (STUNT), extends STUN allowing applications behind a NAT to
discover the NATs behaviour for TCP packets and to learn the
transport address binding allocated by the NAT.  Using STUNT,
applications can establish raw TCP sessions with other NAT'ed hosts
without using encapsulation, tunelling, relaying or a userspace
stack, and without forfeiting any of benefits of using TCP.  Like
STUN, STUNT requires no changes to NATs and works with a large
majority of NATs currently present in the network architechture.

<P>

<H1><A NAME="SECTION00630000000000000000">
Hole Punching</A>
</H1>

<H2><A NAME="SECTION00631000000000000000">
UDP Hole Punching</A>
</H2>

<P>
This approach enables to establish a direct UDP session between two
nodes, even when both may lie behind different NATs, with the help
of a well-known third machine, the <I>connection broker.</I> The connection
broker must have a public address to allow the NAT'ed peers to contact
it and helps them to discover the other peer's public address. UDP
hole punching relies on the properties of common firewalls and NATs
to allow peer-to-peer applications to <I>punch holes</I> and establish
direct connection with each other. This technique works good with
UDP, but we will see that, with some modifications and attentions,
it can works with TCP too.

<P>
We will consider three specific scenarios, and how applications can
be designed to handle both of them gracefully. In the first situation,
representing the common case, two nodes desiring direct peer-to-peer
communication reside behind two different NATs. In the second, the
two peers reside behind multiple levels of NAT and the last scenarios
shows two clients that reside behind the same NAT, but do not necessarily
know that they do.

<P>

<H4><A NAME="SECTION00631010000000000000">
Peers behind different NATs</A>
</H4>

<P>
...

<P>

<H4><A NAME="SECTION00631020000000000000">
Peers behind multiple levels of NAT</A>
</H4>

<P>
...

<P>

<H4><A NAME="SECTION00631030000000000000">
Peers behind the same NAT: the hairpin translation</A>
</H4>

<P>
...

<P>

<H4><A NAME="SECTION00631040000000000000">
Create a peer-to-peer UDP session</A>
</H4>

<P>
...

<P>

<H2><A NAME="SECTION00632000000000000000">
TCP Hole Punching</A>
</H2>

<P>
To establish a peer-to-peer TCP session we have to use a more refined
approach, but this approach is very similar to the UDP hole punching.
It is more complicated because from a TCP packet the NAT can extracts
much more informations than from an UDP packet.

<P>

<H4><A NAME="SECTION00632010000000000000">
Create a peer-to-peer TCP session</A>
</H4>

<P>
...
<HR>
<!--Navigation Panel-->
<A NAME="tex2html154"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html150"
  HREF="ntcp.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html144"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A> 
<A NAME="tex2html152"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="file:/usr/share/latex2html/icons/contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html155"
  HREF="node7.html">Our Approach</A>
<B> Up:</B> <A NAME="tex2html151"
  HREF="ntcp.html">Peer-to-Peer Reliable Connectivity Across</A>
<B> Previous:</B> <A NAME="tex2html145"
  HREF="node5.html">Solution requirements</A>
 &nbsp; <B>  <A NAME="tex2html153"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Gaballo Luca
2005-07-05
</ADDRESS>
</BODY>
</HTML>
